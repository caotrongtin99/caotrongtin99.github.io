[{"content":"There are two types of pre-rendering in Next.js. So what are they and which is the best approach?\nTable of Contents Rendering on Server Pre-rendering Server Side Rendering Static Site Generation Use cases Wrap Up Rendering on Server ‚úçÔ∏è Explain:\nWhen users request to server, server will sent a generated HTML file. After that, ReactDOM.hydrate() will run to hydrate (attach event listeners) the HTML rendered from the server. After hydration process, the website becomes interactive.\nPre-rendering In Next.js, it pre-renders every page. It prepares a generated HTML and Javascript code for that page. After HTML is loaded, hydration process will execute to make the page completely interactive.\nPre-rendering makes better UX, performance and SEO.\nWith some steps, you can check pre-rendering process on the browser. Let\u0026rsquo;s test with this page page.\n1Ô∏è‚É£ Disable Javascript in your browser. 2Ô∏è‚É£ Let\u0026rsquo;s see the result.\nAccess the link, you can see UI is rendered. Without JS, page navigation works incorrectly, when we click on links on the page, the page will be reloaded.\nOn the other hand, if our app is client side rendering Reactjs app, there\u0026rsquo;s no pre-rendering, so we will see a blank page if javascript is disabled.\nThe result like this:\n‚öíÔ∏è Pre-rendering vs No Pre-rendering üìå There are two forms of Pre-rendering: Static Site Generation and Server Side Rendering\nStatic Site Generation The HTML will be generated at build time (when you run next build). It can be cached by CDN and is used on each request.\nStatic Generation Without Data\nBy default, Next.js pre-renders pages using Static Generation without fetching data.\nüöÄ Example:\nfunction About() { return \u0026lt;div\u0026gt;About\u0026lt;/div\u0026gt; } export default About The page does not need to fetch any external data to be pre-rendered.\nStatic Generation With Data\nIt requires fetching date for pre-rendering. There are two cases:\nYour page content depends on external data (getStaticProps) Your page paths depends on external data (getStaticPaths) Server Side Rendering The HTML page is generated on each request.\nTo use SSR, we need to export getServerSideProps in the component, data will be fetched at request time so Time to first byte will be slower than getStaticProps\nexport async function getServerSideProps(context) { return { props: { // props for your component }, }; } Use cases You can use SSG for many cases::\nMarketing Pages Blog posts E-commerce product listing Help \u0026amp; Documentation If the data needs to be up-to-date with every request, we should use SSR, the page content changes on every request.\nWrap Up SSG is recommended to be used more than SSR because HTML is generated at build time so it can be reused on each request.\nEspecially, Next.js allows you to choose pre-rendering form to use for each page.\n","permalink":"https://caotrongtin99.github.io/posts/ssr-ssg/","summary":"There are two types of pre-rendering in Next.js. So what are they and which is the best approach?\nTable of Contents Rendering on Server Pre-rendering Server Side Rendering Static Site Generation Use cases Wrap Up Rendering on Server ‚úçÔ∏è Explain:\nWhen users request to server, server will sent a generated HTML file. After that, ReactDOM.hydrate() will run to hydrate (attach event listeners) the HTML rendered from the server. After hydration process, the website becomes interactive.","title":"Server Side Rendering \u0026 Static Site Generation"},{"content":"Table of Contents How HTML displayed on browser Script Tag Async attribute Defer attribute Difference beetween Async and Defer Use cases How HTML displayed on browser First, browser will download resources and parse HTML to display. HTML is parsed as soon as resources are loaded\nScript Tag To load a javascript file, we use script tag\n\u0026lt;script src=\u0026#34;/path/to/script.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; üëáÔ∏èBelow is loading process: ‚úçÔ∏è Explain:\nFirst, HTML code will be parsed until reach script tag, script will be downloaded. After that, script will be executed. After executing the script, continue to execute the DOM analysis.\n‚õîÔ∏è Drawback:\nThis case above results in a bad user experience because the user cannot interact with the page while the script is being downloaded.\nTo avoid that, HTML5 provides two attributes: async and defer\nAsync attribute üü¢ Declaration syntax\n\u0026lt;script src=\u0026#34;/path/to/script.js\u0026#34; defer\u0026gt;\u0026lt;/script\u0026gt; üëáÔ∏èBelow is loading process when using defer attribute: ‚úçÔ∏è Explain:\nDownloading script run parallel with parsing the document. After script is downloaded, parsing HTML is paused and script will be executed. After script is executed successfully, parsing HTML is continue.\nDefer attribute üü¢ Declaration syntax\n\u0026lt;script src=\u0026#34;/path/to/script.js\u0026#34; async\u0026gt;\u0026lt;/script\u0026gt; üëáÔ∏èBelow is loading process when using async attribute: ‚úçÔ∏è Explain:\nThe process is quite similar to above process. Downloading script run parallel with parsing the document. After parsing HTML is compeleted, script will be executed.\nDifference beetween Async and Defer The first difference is loading process as mentioned above. When using async, scripts may not be executed in order because scripts are executed as soon as they are completely downloaded. On the other hand, the scripts used defer guarantee the order of execution. Use cases 1Ô∏è‚É£ Use cases of defer\nGets loaded as soon as possible ‚Äî so it reduces load times. Guarantee scripts order Your script requires the DOM 2Ô∏è‚É£ Use case of async\nYour script dont need the DOM The script doesn\u0026rsquo;t depend on other scripts (ex: Google Analytics) Loading script in the middle Example:\n\u0026lt;div class=\u0026#34;middle\u0026#34;\u0026gt; \u0026lt;script async src=\u0026#34;./script.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/div\u0026gt; Because the DOM is already present, the script can be executed without problems.\n","permalink":"https://caotrongtin99.github.io/posts/javascript-load/","summary":"Table of Contents How HTML displayed on browser Script Tag Async attribute Defer attribute Difference beetween Async and Defer Use cases How HTML displayed on browser First, browser will download resources and parse HTML to display. HTML is parsed as soon as resources are loaded\nScript Tag To load a javascript file, we use script tag\n\u0026lt;script src=\u0026#34;/path/to/script.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; üëáÔ∏èBelow is loading process: ‚úçÔ∏è Explain:\nFirst, HTML code will be parsed until reach script tag, script will be downloaded.","title":"Async and defer in Javascript loading"},{"content":"Table of Contents Functions Pure Functions Side Effects Example Why is it important? Let\u0026rsquo;s explore what pure function is üëá\nFunctions? Function is a execution of a task. It receives input and returns a value.\nPure Functions What is a pure function?\nA function always returns same output if it is passed constant parameters. It doesn\u0026rsquo;t depends on any state or data, it just depend on its input parameters. This function does not have any effect on other objects, such as requests, input, output or data mutations. Side Effects Side Effects are interactions to outside the function. That can be anything from changing a variable that exists outside of a function, to calling another function from within a function. Common side effects:\nHTPP Request Print data to console Interact DOM Math.ramdom() Get current date time \u0026hellip; Example An example of a function calculating the product price\nfunction priceAfterTax(productPrice) { return (productPrice * 0.1) + productPrice; } This function isn\u0026rsquo;t dependent on external variables and doesn\u0026rsquo;t produce side effects, so it\u0026rsquo;s a pure function.\nAnother example\nvar tax = 10; function calculateTax(productPrice) { return (productPrice * (tax/100)) + productPrice; } This function is dependent on an external variable, so it isn\u0026rsquo;t a pure function.\nWhy is it important? Pure function is used a lot in functional programming. It is useful for testing and refactoring. Because it always returns same outputs with same inputs, testing becomes easier. Besides, it doesn\u0026rsquo;t affects external environment, so refactoring becomes more convenient. In conclusion, pure functions will help improve the quality of code, make clean code, and be easy to maintainance.\n","permalink":"https://caotrongtin99.github.io/posts/pure-function-js/","summary":"Table of Contents Functions Pure Functions Side Effects Example Why is it important? Let\u0026rsquo;s explore what pure function is üëá\nFunctions? Function is a execution of a task. It receives input and returns a value.\nPure Functions What is a pure function?\nA function always returns same output if it is passed constant parameters. It doesn\u0026rsquo;t depends on any state or data, it just depend on its input parameters. This function does not have any effect on other objects, such as requests, input, output or data mutations.","title":"Pure Function in Javascript"},{"content":"Table of Contents Shallow Copy Deep Copy Problem Solution Wrap Up Shallow Copy Shallow Copy is a copy whose properties share the same references (point to the same underlying values) as those of the source object from which the copy was made. As a result, when you change either the source or the copy, you may also cause the other object to change too ‚Äî and so, you may end up unintentionally causing changes to the source or copy that you don\u0026rsquo;t expect.\nconst obj = { name: \u0026#39;Tin\u0026#39;, age: 22 } const clonedObject = obj clonedObject.age = 18 console.log(obj.age) // 18 console.log(clonedObject.age) // 18 Deep Copy Deep copy of an object is a copy whose properties do not share the same references (point to the same underlying values) as those of the source object from which the copy was made. As a result, when you change either the source or the copy, you can be assured you\u0026rsquo;re not causing the other object to change too; that is, you won\u0026rsquo;t unintentionally be causing changes to the source or copy that you don\u0026rsquo;t expect.\n‚öíÔ∏è Ways to deep copy an object:\n1Ô∏è‚É£ Using Spread operator\nconst obj = { name: \u0026#39;Tin\u0026#39;, age: 22 } const clonedObject = {...obj} clonedObject.age = 18 console.log(obj.age) // 22 console.log(clonedObject.age) // 18 2Ô∏è‚É£ Using Object.assign()\nconst obj = { name: \u0026#39;Tin\u0026#39;, age: 22 } const clonedObject = Object.assign({}, obj) clonedObject.age = 18 console.log(obj.age) // 22 console.log(clonedObject.age) // 18 üÜò The Risk\nThere is a problem that is nested object\nconst obj = { name: \u0026#39;Tin\u0026#39;, age: 22, job: { title: \u0026#39;Software Engineer\u0026#39;, yoe: 2 } } const clonedObj = {...obj} clonedObj.job.yoe = 5 console.log(obj.job.yoe) // 5 console.log(clonedObj.job.yoe) // 5 It is not full deep copy.\nüí° Solution\nTo solve the problem, we stringify the object and then parse it.\nconst obj = { name: \u0026#39;Tin\u0026#39;, age: 22, job: { title: \u0026#39;Software Engineer\u0026#39;, yoe: 2 } } const clonedObj = JSON.parse(JSON.stringify(obj)) clonedObj.job.yoe = 5 console.log(obj.job.yoe) // 23 console.log(clonedObj.job.yoe) // 5 Problem When you have a nested data in an array or an object, the spread operator and Object.assign() will only DEEP-COPY the outer properties of the object. From the second child, it will only copy shallow.\n‚úçÔ∏è Example\nAssume we have a state\n{ name: \u0026#39;Tin\u0026#39;, age: 22, job: { title: \u0026#39;Software Engineer\u0026#39;, yoe: 2 } } Some ways that developers are using to update the state\nsetState(prev =\u0026gt; { prev.job.yoe = 3 }) setState(prev =\u0026gt; { prev.job.yoe = 4 return prev }) // These ways are not work because it doesn\u0026#39;t return a deep object. setState(prev =\u0026gt; { const cloned = {...prev} cloned.job = { title: \u0026#39;Data Science\u0026#39; } return cloned; }) // For example, assume we have Pure Component are watching prop {age}. // But Pure Component will not regconize prop changes so it will not be re-rendered, because Pure Component will only compare shallow. Solution A solution for the problem is using hook useImmer. In essence, the hook will help us to create a deep copy of the state.\nconst [engineer, setEngineer] = useImmer({ name: \u0026#39;Tin\u0026#39;, age: 22, job: { title: \u0026#39;Software Engineer\u0026#39;, yoe: 2 } }) // Update state setEngineer(prev =\u0026gt; { prev.age = 23 return prev }) Wrap Up Shouldn\u0026rsquo;t update states by shallow copy Use useImmer instead of useState to update nested object states. ","permalink":"https://caotrongtin99.github.io/posts/update-nested-state/","summary":"Table of Contents Shallow Copy Deep Copy Problem Solution Wrap Up Shallow Copy Shallow Copy is a copy whose properties share the same references (point to the same underlying values) as those of the source object from which the copy was made. As a result, when you change either the source or the copy, you may also cause the other object to change too ‚Äî and so, you may end up unintentionally causing changes to the source or copy that you don\u0026rsquo;t expect.","title":"How to update nested state correctly in React Hook"},{"content":"Table of Contents Prerequisites Reconciliation Reconciliation vs Rendering Scheduling React Fiber React Fiber is an ongoing reimplementation of React\u0026rsquo;s core algorithm. It is the culmination of over two years of research by the React team.\nPrerequisites A few things to know before diving into React Fiber:\nReact Components, Elements, Instances Reconciliation React Basic Theoretical Concepts React design Principles Reconciliation Reconciliation is an algorithm that React uses to distinguish one DOM tree from another to determine which parts need to be changed.\nFor example, when you render your React application, a tree including nodes describing that application will be created and saved in memory. This tree is then reassembled to match the rendering environment (compare with old tree to calculate what operations are needed to update React app).\nReconciliation vs Rendering Reconciliation and Rendering are separate stages.\nReconciler does the work of calcutation what parts of tree are changed. Besides, Renderer uses that infomation to update rendered application.\nScheduling Scheduling is a process of determine when a job is executed. Important points are:\nIn a user interface, it is necessary to update everything at once. In fact, doing so can be very wasteful, causing frame drops (FPS) There are two approaches: one will need the application or yourself - the programmer decides the schedule of work or one way will let the framework here be React to decide for you. React is currently not using scheduling properly. Re-rendering seems to be done immediately upon changes. Leveraging the benefits of planning was a key idea for moving forward with Fiber.\nReact Fiber Fiber primary goal is to enable React to take advantage of Scheduling\nSpecifically we need:\nStop the work and return to execulation after Set priority for different works Reuse completed works Ignore works that are no longer needed To do this, we first need a way to break down a task into smaller units. In a sense, a Fiber represents a unit of work. Going back to the idea in \u0026ldquo;React Components as functions of data\u0026rdquo;, usually expressed as v = f(d).\nRendering a React app like a fucntion call that contains calls to other functions and so on. The way that typical computers trace an execution of a program is using the Call Stack. When a function is executed, a Stack Frame is added to the queue, that Stack Frame represents the work executed by that function.\nWhen working with user interfaces, a problem here is that there are many works executed at once, it might cause Animation to drop FPS and look terible. Addition, some works might become unnecessary if they are replaced by more recent updates. This is where the comparision of UI elements and functions is break down because normally components have more specific relationships than functions.\nNewer browsers install APIs to help indicate the problem. requestIdleCallback schedules a low priority function to be called during idle and requestAnimationFrame schedules high priority functions that can be called in next frame. The point is that you need to breakdown render tasks to small units to use those APIs. If you just depend on Call Stack, it will work until stack is empty. It would be better if we can modify behavior of Call Stack to optimize UI rendering? It would be better if we\u0026rsquo;re able to interrupt Call Stack as we like and control Stack Frame manually. That is the goal of React Fiber.\nBesides scheduling, handling Stack Frames manually opens up the potential for features like Concurrency and Error Boundaries.\n","permalink":"https://caotrongtin99.github.io/posts/react-fiber/","summary":"Table of Contents Prerequisites Reconciliation Reconciliation vs Rendering Scheduling React Fiber React Fiber is an ongoing reimplementation of React\u0026rsquo;s core algorithm. It is the culmination of over two years of research by the React team.\nPrerequisites A few things to know before diving into React Fiber:\nReact Components, Elements, Instances Reconciliation React Basic Theoretical Concepts React design Principles Reconciliation Reconciliation is an algorithm that React uses to distinguish one DOM tree from another to determine which parts need to be changed.","title":"React Fiber"},{"content":"Table of Contents What is Intersection Observer API Some features Usage Example In the past, it\u0026rsquo;s difficult to determine a element is visible in the viewport or not, or how long the user was reading this content. Intersection Observer API offers some features that help users to improve user exprerience and speed up the website.\n‚ùî What is Intersection Observer API? Intersection Observer API offers a way to asynchronously observe changes in UI with ancestor elements or high-level document\u0026rsquo;s viewports. üöÄ Some features Lazy loading images or content Infinite Scrolling Report on ad visibility to calculate revenue Decide whether to perform actions or animations based on whether the user sees it. ‚û°Ô∏è Usage 1. Create Intersection Observer Object\nfunction handler(entries, observer) { console.log(entries); } const config = { root: null, rootMargin: \u0026#39;0px\u0026#39;, threshold: 1.0 }; const observer = new IntersectionObserver(handler, config); ‚úçÔ∏è Explain:\nroot: a parent elememt of listened element. root: null means the parent is document rootMargin: addding margin to root threshold: This option will limit the callback. Its value is in the range 0-1. Or maybe an array. Example: 1: callback will be called when the element is 100% visible on the viewport. 0: callback will be called when element as soon as the element is 1px visible on the viewport. It\u0026rsquo;s also default value. 0.5: callback will be called when the element is 50% visible on the viewport. [0, 0.5, 1]: callback will be called when element is 1px, 50%, 100% visible on the viewport. In the callback handler function, there is an entries parameter, which is the array of elements to be listened to if they change. These entries also have additional counters to check for the occurrence of that element\n2. Apply element to Intersection Observer object\nconst image = document.getElementById(\u0026#39;image\u0026#39;); observer.observe(image); Besides, we can observe many elements at the same time with the same observer object.\nconst images = document.querySelectorAll(\u0026#39;.image\u0026#39;); images.forEach(image) { observer.observe(image); }); 3. Unsubcribe observer When we dont want to listen anymore, we can use the following ways:\nobserver.unobserver(element);// unsubcribe for a previously listened element. observer.disconnect();// unsubcribe for all elements. ‚öíÔ∏è Example For example we want to automatically play the video when we scroll to the video and pause when we scroll through it.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;section style=\u0026#34;margin-top: 100px; height: 100vh; background-color: yellow;\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;TOP SECTION\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;video id=\u0026#34;video\u0026#34; data-testid=\u0026#34;video-asset\u0026#34; style=\u0026#34;width:100%;height:auto\u0026#34; src=\u0026#34;https://media.istockphoto.com/videos/small-cascading-creek-video-id1321347364\u0026#34; alt=\u0026#34;L·∫°ch t·∫ßng nh·ªè - Tr·∫£ ph√≠ B·∫£n quy·ªÅn M·ªôt l·∫ßn R·ª´ng Stock Footage Video\u0026#34; controls=\u0026#34;\u0026#34; controlslist=\u0026#34;nodownload\u0026#34; autoplay=\u0026#34;\u0026#34; muted=\u0026#34;muted\u0026#34; loop=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/video\u0026gt; \u0026lt;section style=\u0026#34;margin-top: 100px; height: 100vh; background-color: red;\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;BOTTOM SECTION\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;script\u0026gt; const video = document.getElementById(\u0026#39;video\u0026#39;); function handler(entries) { const videoEntry = entries[0]; if(videoEntry.isIntersecting) { video?.play(); } else { video?.pause(); } } const observer = new IntersectionObserver(handler, ); observer.observe(video); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; You can find the source code on my Github Repo\n","permalink":"https://caotrongtin99.github.io/posts/intersection-observer/","summary":"Table of Contents What is Intersection Observer API Some features Usage Example In the past, it\u0026rsquo;s difficult to determine a element is visible in the viewport or not, or how long the user was reading this content. Intersection Observer API offers some features that help users to improve user exprerience and speed up the website.\n‚ùî What is Intersection Observer API? Intersection Observer API offers a way to asynchronously observe changes in UI with ancestor elements or high-level document\u0026rsquo;s viewports.","title":"What is Intersection Observer API?"},{"content":"Table of Contents Memory Leak Solve the problem Some memory leak cases in React In conclusion Memory Leak Memory leak is a type of resource leak that occurs when a computer program incorrectly manages memory allocations. Sometimes, we get a warning about memory leak in our React applications such as Can\u0026rsquo;t perform a React state update on an unmounted component. We shouldn\u0026rsquo;t update state in an unmounted component. For example, we are fetching data at the first mouting to update component states, but we immediately navigate to another page or take other actions to make the component unmounted so state updating becomes unuseful. That\u0026rsquo;s a reason why React warns the message.\nA block of code related to that example:\nconst Component = () =\u0026gt; { const [data, setData] = useState([]) useEffect(() =\u0026gt; { fetchData().then(data =\u0026gt; setData(data)) }, []) return ( \u0026lt;\u0026gt; // render component \u0026lt;/\u0026gt; ) } The problem is that while fetchData was running, suddenly the component was unmounted. When Promise is settled, callback handler will be executed, a part of memory has been reserved for storing the results returned from the API (perform setData), so that\u0026rsquo;s useless and superfluous.\nSolve the problem Solution 1: use a flag to check whether the component is unmounted or not const Component = () =\u0026gt; { const [data, setData] = useState([]) useEffect(() =\u0026gt; { let isUnmounted = false fetchData().then(data =\u0026gt; { if (isUnmounted) return setData(data) }) return () =\u0026gt; { isUnmount = true } }, []) return ( \u0026lt;\u0026gt; // render component \u0026lt;/\u0026gt; ) } Solution 2: use AbortController to cancel request const Component = () =\u0026gt; { const [data, setData] = useState([]) useEffect(() =\u0026gt; { const controller = new AbortController(); // fetch data axios.get(\u0026#39;/\u0026#39;, { signal: controller.signal }).then(function(data) { setData(data) }); return () =\u0026gt; { controller.abort(); }; }, []) return ( \u0026lt;\u0026gt; // render component \u0026lt;/\u0026gt; ) } Some memory leak cases in React There are some cases that make memory leaks in Reactjs:\nDon\u0026rsquo;t clean up subscription when unmounting Don\u0026rsquo;t clean DOM event when unmouting Don\u0026rsquo;t clean timer when unmouting In conclusion ","permalink":"https://caotrongtin99.github.io/posts/memory-leak-react/","summary":"Table of Contents Memory Leak Solve the problem Some memory leak cases in React In conclusion Memory Leak Memory leak is a type of resource leak that occurs when a computer program incorrectly manages memory allocations. Sometimes, we get a warning about memory leak in our React applications such as Can\u0026rsquo;t perform a React state update on an unmounted component. We shouldn\u0026rsquo;t update state in an unmounted component. For example, we are fetching data at the first mouting to update component states, but we immediately navigate to another page or take other actions to make the component unmounted so state updating becomes unuseful.","title":"Memory Leak Problems in Reactjs"},{"content":"Table of Contents Timezones ISO 8061 format Date Constructions Hi there üëã, i see that many developers are facing with problems about Date in javascript recently. Today, I gonna to show you how to use Date in js correctly.\nTimezones There are 2 definitions about timezones in js: UTC and Local time zones Local time refers to the timezone your computer is in.\nUTC is synonymous with Greenwich Mean Time (GMT) in practice.\nISO 8061 format What is it? It\u0026rsquo;s an international standard introduced by ISO in 1988. Acctually, it describes the way to write date, time easily that our computers can understand it.\nDate constructions Syntax\nnew Date() new Date(value) new Date(dateString) new Date(dateObject) new Date(year, monthIndex) new Date(year, monthIndex, day) new Date(year, monthIndex, day, hours) new Date(year, monthIndex, day, hours, minutes) new Date(year, monthIndex, day, hours, minutes, seconds) new Date(year, monthIndex, day, hours, minutes, seconds, milliseconds) ","permalink":"https://caotrongtin99.github.io/posts/date-js/","summary":"Table of Contents Timezones ISO 8061 format Date Constructions Hi there üëã, i see that many developers are facing with problems about Date in javascript recently. Today, I gonna to show you how to use Date in js correctly.\nTimezones There are 2 definitions about timezones in js: UTC and Local time zones Local time refers to the timezone your computer is in.\nUTC is synonymous with Greenwich Mean Time (GMT) in practice.","title":"Understanding Date in Javascript"},{"content":"My name is Tin Cao I have about 2+ years of experience building modern web applications. My strengths are having a strong, deep base of knowledge and quickly getting used to tech\nI\u0026rsquo;m currently working as a Software Engineer, at Bloom.\nI have just finished my Software Engineering studies at the HCM University of Science\nIn my free time, I play greek rembetiko music on the guitar and administrate the rembetiko.gr community.\nFrom time to time you can read some of my thoughts, projects and ideas that I share on my blog.\n","permalink":"https://caotrongtin99.github.io/about/","summary":"About","title":""}]