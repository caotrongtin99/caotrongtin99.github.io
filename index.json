[{"content":"React Fiber is an ongoing reimplementation of React\u0026rsquo;s core algorithm. It is the culmination of over two years of research by the React team.\nPrerequisites A few things to know before diving into React Fiber:\nReact Components, Elements, Instances Reconciliation React Basic Theoretical Concepts React design Principles Reconciliation Reconciliation is an algorithm that React uses to distinguish one DOM tree from another to determine which parts need to be changed.\nFor example, when you render your React application, a tree including nodes describing that application will be created and saved in memory. This tree is then reassembled to match the rendering environment (compare with old tree to calculate what operations are needed to update React app).\nReconciliation vs Rendering Reconciliation and Rendering are separate stages.\nReconciler does the work of calcutation what parts of tree are changed. Besides, Renderer uses that infomation to update rendered application.\nScheduling Scheduling is a process of determine when a job is executed. Important points are:\nIn a user interface, it is necessary to update everything at once. In fact, doing so can be very wasteful, causing frame drops (FPS) There are two approaches: one will need the application or yourself - the programmer decides the schedule of work or one way will let the framework here be React to decide for you. React is currently not using scheduling properly. Re-rendering seems to be done immediately upon changes. Leveraging the benefits of planning was a key idea for moving forward with Fiber.\nReact Fiber Fiber primary goal is to enable React to take advantage of Scheduling\nSpecifically we need:\nStop the work and return to execulation after Set priority for different works Reuse completed works Ignore works that are no longer needed To do this, we first need a way to break down a task into smaller units. In a sense, a Fiber represents a unit of work. Going back to the idea in \u0026ldquo;React Components as functions of data\u0026rdquo;, usually expressed as v = f(d).\nRendering a React app like a fucntion call that contains calls to other functions and so on. The way that typical computers trace an execution of a program is using the Call Stack. When a function is executed, a Stack Frame is added to the queue, that Stack Frame represents the work executed by that function.\nWhen working with user interfaces, a problem here is that there are many works executed at once, it might cause Animation to drop FPS and look terible. Addition, some works might become unnecessary if they are replaced by more recent updates. This is where the comparision of UI elements and functions is break down because normally components have more specific relationships than functions.\nNewer browsers install APIs to help indicate the problem. requestIdleCallback schedules a low priority function to be called during idle and requestAnimationFrame schedules high priority functions that can be called in next frame. The point is that you need to breakdown render tasks to small units to use those APIs. If you just depend on Call Stack, it will work until stack is empty. It would be better if we can modify behavior of Call Stack to optimize UI rendering? It would be better if we\u0026rsquo;re able to interrupt Call Stack as we like and control Stack Frame manually. That is the goal of React Fiber.\nBesides scheduling, handling Stack Frames manually opens up the potential for features like Concurrency and Error Boundaries.\n","permalink":"https://caotrongtin99.github.io/posts/react-fiber/","summary":"React Fiber is an ongoing reimplementation of React\u0026rsquo;s core algorithm. It is the culmination of over two years of research by the React team.\nPrerequisites A few things to know before diving into React Fiber:\nReact Components, Elements, Instances Reconciliation React Basic Theoretical Concepts React design Principles Reconciliation Reconciliation is an algorithm that React uses to distinguish one DOM tree from another to determine which parts need to be changed.","title":"React Fiber"},{"content":"Hi there, i see that many developers are facing with problems about Date in javascript recently. Today, I gonna to show you how to use Date in js correctly.\nTimezones There are 2 definitions about timezones in js: UTC and Local time zones Local time refers to the timezone your computer is in.\nUTC is synonymous with Greenwich Mean Time (GMT) in practice.\nISO 8061 format What is it? It\u0026rsquo;s an international standard introduced by ISO in 1988. Acctually, it describes the way to write date, time easily that our computers can understand it.\nDate constructions Syntax\nnew Date() new Date(value) new Date(dateString) new Date(dateObject) new Date(year, monthIndex) new Date(year, monthIndex, day) new Date(year, monthIndex, day, hours) new Date(year, monthIndex, day, hours, minutes) new Date(year, monthIndex, day, hours, minutes, seconds) new Date(year, monthIndex, day, hours, minutes, seconds, milliseconds) ","permalink":"https://caotrongtin99.github.io/posts/date-js/","summary":"Hi there, i see that many developers are facing with problems about Date in javascript recently. Today, I gonna to show you how to use Date in js correctly.\nTimezones There are 2 definitions about timezones in js: UTC and Local time zones Local time refers to the timezone your computer is in.\nUTC is synonymous with Greenwich Mean Time (GMT) in practice.\nISO 8061 format What is it? It\u0026rsquo;s an international standard introduced by ISO in 1988.","title":"Understanding Date in Javascript"},{"content":"Let\u0026rsquo;s explore what pure function is üëá\nFunctions? Function is a execution of a task. It receives input and returns a value.\nPure Functions What is a pure function?\nA function always returns same output if it is passed constant parameters. It doesn\u0026rsquo;t depends on any state or data, it just depend on its input parameters. This function does not have any effect on other objects, such as requests, input, output or data mutations. Side Effects Side Effects are interactions to outside the function. That can be anything from changing a variable that exists outside of a function, to calling another function from within a function. Common side effects:\nHTPP Request Print data to console Interact DOM Math.ramdom() Get current date time \u0026hellip; Example An example of a function calculating the product price\nfunction priceAfterTax(productPrice) { return (productPrice * 0.1) + productPrice; } This function isn\u0026rsquo;t dependent on external variables and doesn\u0026rsquo;t produce side effects, so it\u0026rsquo;s a pure function.\nAnother example\nvar tax = 10; function calculateTax(productPrice) { return (productPrice * (tax/100)) + productPrice; } This function is dependent on an external variable, so it isn\u0026rsquo;t a pure function.\nWhy is it important? Pure function is used a lot in functional programming. It is useful for testing and refactoring. Because it always returns same outputs with same inputs, testing becomes easier. Besides, it doesn\u0026rsquo;t affects external environment, so refactoring becomes more convenient. In conclusion, pure functions will help improve the quality of code, make clean code, and be easy to maintainance.\n","permalink":"https://caotrongtin99.github.io/posts/pure-function-js/","summary":"Let\u0026rsquo;s explore what pure function is üëá\nFunctions? Function is a execution of a task. It receives input and returns a value.\nPure Functions What is a pure function?\nA function always returns same output if it is passed constant parameters. It doesn\u0026rsquo;t depends on any state or data, it just depend on its input parameters. This function does not have any effect on other objects, such as requests, input, output or data mutations.","title":"Pure Function in Javascript"},{"content":"In the past, it\u0026rsquo;s difficult to determine a element is visible in the viewport or not, or how long the user was reading this content. Intersection Observer API offers some features that help users to improve user exprerience and speed up the website.\n‚ùî What is Intersection Observer API? Intersection Observer API offers a way to asynchronously observe changes in UI with ancestor elements or high-level document\u0026rsquo;s viewports. üöÄ Some features Lazy loading images or content Infinite Scrolling Report on ad visibility to calculate revenue Decide whether to perform actions or animations based on whether the user sees it. ‚û°Ô∏è Usage 1. Create Intersection Observer Object\nfunction handler(entries, observer) { console.log(entries); } const config = { root: null, rootMargin: \u0026#39;0px\u0026#39;, threshold: 1.0 }; const observer = new IntersectionObserver(handler, config); ‚úçÔ∏è Explain:\nroot: a parent elememt of listened element. root: null means the parent is document rootMargin: addding margin to root threshold: This option will limit the callback. Its value is in the range 0-1. Or maybe an array. Example: 1: callback will be called when the element is 100% visible on the viewport. 0: callback will be called when element as soon as the element is 1px visible on the viewport. It\u0026rsquo;s also default value. 0.5: callback will be called when the element is 50% visible on the viewport. [0, 0.5, 1]: callback will be called when element is 1px, 50%, 100% visible on the viewport. In the callback handler function, there is an entries parameter, which is the array of elements to be listened to if they change. These entries also have additional counters to check for the occurrence of that element\n2. Apply element to Intersection Observer object\nconst image = document.getElementById(\u0026#39;image\u0026#39;); observer.observe(image); Besides, we can observe many elements at the same time with the same observer object.\nconst images = document.querySelectorAll(\u0026#39;.image\u0026#39;); images.forEach(image) { observer.observe(image); }); 3. Unsubcribe observer When we dont want to listen anymore, we can use the following ways:\nobserver.unobserver(element);// unsubcribe for a previously listened element. observer.disconnect();// unsubcribe for all elements. ‚öíÔ∏è Example For example we want to automatically play the video when we scroll to the video and pause when we scroll through it.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;section style=\u0026#34;margin-top: 100px; height: 100vh; background-color: yellow;\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;TOP SECTION\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;video id=\u0026#34;video\u0026#34; data-testid=\u0026#34;video-asset\u0026#34; style=\u0026#34;width:100%;height:auto\u0026#34; src=\u0026#34;https://media.istockphoto.com/videos/small-cascading-creek-video-id1321347364\u0026#34; alt=\u0026#34;L·∫°ch t·∫ßng nh·ªè - Tr·∫£ ph√≠ B·∫£n quy·ªÅn M·ªôt l·∫ßn R·ª´ng Stock Footage Video\u0026#34; controls=\u0026#34;\u0026#34; controlslist=\u0026#34;nodownload\u0026#34; autoplay=\u0026#34;\u0026#34; muted=\u0026#34;muted\u0026#34; loop=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/video\u0026gt; \u0026lt;section style=\u0026#34;margin-top: 100px; height: 100vh; background-color: red;\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;BOTTOM SECTION\u0026lt;/h1\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;script\u0026gt; const video = document.getElementById(\u0026#39;video\u0026#39;); function handler(entries) { const videoEntry = entries[0]; if(videoEntry.isIntersecting) { video?.play(); } else { video?.pause(); } } const observer = new IntersectionObserver(handler, ); observer.observe(video); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","permalink":"https://caotrongtin99.github.io/posts/intersection-observer/","summary":"In the past, it\u0026rsquo;s difficult to determine a element is visible in the viewport or not, or how long the user was reading this content. Intersection Observer API offers some features that help users to improve user exprerience and speed up the website.\n‚ùî What is Intersection Observer API? Intersection Observer API offers a way to asynchronously observe changes in UI with ancestor elements or high-level document\u0026rsquo;s viewports. üöÄ Some features Lazy loading images or content Infinite Scrolling Report on ad visibility to calculate revenue Decide whether to perform actions or animations based on whether the user sees it.","title":"What is Intersection Observer API?"},{"content":"Memory Leak Memory leak is a type of resource leak that occurs when a computer program incorrectly manages memory allocations. Sometimes, we get a warning about memory leak in our React applications such as Can\u0026rsquo;t perform a React state update on an unmounted component. We shouldn\u0026rsquo;t update state in an unmounted component. For example, we are fetching data at the first mouting to update component states, but we immediately navigate to another page or take other actions to make the component unmounted so state updating becomes unuseful. That\u0026rsquo;s a reason why React warns the message.\nA block of code related to that example:\nconst Component = () =\u0026gt; { const [data, setData] = useState([]) useEffect(() =\u0026gt; { fetchData().then(data =\u0026gt; setData(data)) }, []) return ( \u0026lt;\u0026gt; // render component \u0026lt;/\u0026gt; ) } The problem is that while fetchData was running, suddenly the component was unmounted. When Promise is settled, callback handler will be executed, a part of memory has been reserved for storing the results returned from the API (perform setData), so that\u0026rsquo;s useless and superfluous.\nSolve the problem Solution 1: use a flag to check whether the component is unmounted or not const Component = () =\u0026gt; { const [data, setData] = useState([]) useEffect(() =\u0026gt; { let isUnmounted = false fetchData().then(data =\u0026gt; { if (isUnmounted) return setData(data) }) return () =\u0026gt; { isUnmount = true } }, []) return ( \u0026lt;\u0026gt; // render component \u0026lt;/\u0026gt; ) } Solution 2: use AbortController to cancel request const Component = () =\u0026gt; { const [data, setData] = useState([]) useEffect(() =\u0026gt; { const controller = new AbortController(); // fetch data axios.get(\u0026#39;/\u0026#39;, { signal: controller.signal }).then(function(data) { setData(data) }); return () =\u0026gt; { controller.abort(); }; }, []) return ( \u0026lt;\u0026gt; // render component \u0026lt;/\u0026gt; ) } Some memory leak cases in React There are some cases that make memory leaks in Reactjs:\nDon\u0026rsquo;t clean up subscription when unmounting Don\u0026rsquo;t clean DOM event when unmouting Don\u0026rsquo;t clean timer when unmouting In conclusion ","permalink":"https://caotrongtin99.github.io/posts/memory-leak-react/","summary":"Memory Leak Memory leak is a type of resource leak that occurs when a computer program incorrectly manages memory allocations. Sometimes, we get a warning about memory leak in our React applications such as Can\u0026rsquo;t perform a React state update on an unmounted component. We shouldn\u0026rsquo;t update state in an unmounted component. For example, we are fetching data at the first mouting to update component states, but we immediately navigate to another page or take other actions to make the component unmounted so state updating becomes unuseful.","title":"Memory Leak Problems in Reactjs"},{"content":"My name is Tin Cao I have about 2+ years of experience building modern web applications. My strengths are having a strong, deep base of knowledge and quickly getting used to tech\nI\u0026rsquo;m currently working as a Software Engineer, at Bloom.\nI have just finished my Software Engineering studies at the HCM University of Science\nIn my free time, I play greek rembetiko music on the guitar and administrate the rembetiko.gr community.\nFrom time to time you can read some of my thoughts, projects and ideas that I share on my blog.\n","permalink":"https://caotrongtin99.github.io/about/","summary":"About","title":""}]